"""Configuration file parser for Lagrangian transport simulations."""

from pathlib import Path
from typing import Dict, Any, Optional
import numpy as np


class ConfigManager:
    """Parse and manage configuration files for simulations."""
    
    @staticmethod
    def load(config_path: str) -> Dict[str, Any]:
        """
        Load configuration from file.
        
        File format:
            # Comments
            key = value
        
        Args:
            config_path: Path to configuration file
        
        Returns:
            Dictionary of configuration parameters
        """
        path = Path(config_path)
        if not path.exists():
            raise FileNotFoundError(f"Config not found: {config_path}")
        
        config = {}
        
        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                
                # Skip empty/comment lines
                if not line or line.startswith('#'):
                    continue
                
                if '=' not in line:
                    continue
                
                # Parse key = value
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Remove inline comments
                if '#' in value:
                    value = value.split('#')[0].strip()
                
                # Parse type
                config[key] = ConfigManager._parse_value(value)
        
        return config
    
    @staticmethod
    def _parse_value(value: str) -> Any:
        """Parse string to appropriate Python type."""
        # Boolean
        if value.lower() in ['true', 'false']:
            return value.lower() == 'true'
        
        # Scientific notation
        if 'e' in value.lower() and not value.replace('e', '').replace('-', '').replace('+', '').replace('.', '').isalpha():
            try:
                return float(value)
            except ValueError:
                pass
        
        # Numeric
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except ValueError:
            return value
    
    @staticmethod
    def save(config: Dict[str, Any], config_path: str):
        """
        Save configuration to file.
        
        Args:
            config: Configuration dictionary
            config_path: Output path
        """
        path = Path(config_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'w') as f:
            f.write("# Lagrangian Transport Configuration\n")
            f.write("# Generated by lanun\n\n")
            
            for key, value in sorted(config.items()):
                if isinstance(value, bool):
                    value_str = 'true' if value else 'false'
                elif isinstance(value, float):
                    if abs(value) < 1e-4 or abs(value) > 1e6:
                        value_str = f"{value:.6e}"
                    else:
                        value_str = f"{value}"
                else:
                    value_str = str(value)
                
                f.write(f"{key} = {value_str}\n")
    
    @staticmethod
    def get_default_config(case: str = "case1") -> Dict[str, Any]:
        """
        Get default configuration for a test case.
        
        Args:
            case: Test case identifier
        
        Returns:
            Configuration dictionary
        """
        configs = {
            'case1': {
                'scenario_name': 'Coastal Embayment',
                'description': 'Chlorophyll-a dispersion in 50 km bay',
                'Lx': 50000.0,
                'Ly': 50000.0,
                'H': 100.0,
                'U0': 0.3,
                'tracer_name': 'Chlorophyll-a',
                'tracer_units': 'mg/m³',
                'tracer_background': 0.5,
                'tracer_anomaly': 5.0,
                'nx': 101,
                'ny': 101,
                'particles_per_cell': 4,
                'total_time_days': 7.0,
                'dt': 300.0,
                'output_interval': 100,
                'tracer_center_x_frac': 0.25,
                'tracer_center_y_frac': 0.50,
                'tracer_sigma_frac': 0.10,
            },
            'case2': {
                'scenario_name': 'Marginal Sea',
                'description': 'DIC anomaly in 500 km semi-enclosed sea',
                'Lx': 500000.0,
                'Ly': 500000.0,
                'H': 1000.0,
                'U0': 0.1,
                'tracer_name': 'DIC',
                'tracer_units': 'μmol/kg',
                'tracer_background': 2000.0,
                'tracer_anomaly': 100.0,
                'nx': 101,
                'ny': 101,
                'particles_per_cell': 4,
                'total_time_days': 60.0,
                'dt': 1800.0,
                'output_interval': 50,
                'tracer_center_x_frac': 0.25,
                'tracer_center_y_frac': 0.50,
                'tracer_sigma_frac': 0.08,
            },
            'case3': {
                'scenario_name': 'Volcanic Lake',
                'description': 'Temperature anomaly in 30 km lake',
                'Lx': 30000.0,
                'Ly': 30000.0,
                'H': 500.0,
                'U0': 0.05,
                'tracer_name': 'Temperature',
                'tracer_units': '°C',
                'tracer_background': 20.0,
                'tracer_anomaly': 5.0,
                'nx': 81,
                'ny': 81,
                'particles_per_cell': 4,
                'total_time_days': 14.0,
                'dt': 600.0,
                'output_interval': 80,
                'tracer_center_x_frac': 0.30,
                'tracer_center_y_frac': 0.50,
                'tracer_sigma_frac': 0.12,
            },
            'case4': {
                'scenario_name': 'Estuary Plume',
                'description': 'Sediment plume in 20 km estuary',
                'Lx': 20000.0,
                'Ly': 20000.0,
                'H': 20.0,
                'U0': 0.5,
                'tracer_name': 'Sediment',
                'tracer_units': 'mg/L',
                'tracer_background': 10.0,
                'tracer_anomaly': 100.0,
                'nx': 101,
                'ny': 101,
                'particles_per_cell': 4,
                'total_time_days': 2.0,
                'dt': 120.0,
                'output_interval': 100,
                'tracer_center_x_frac': 0.20,
                'tracer_center_y_frac': 0.50,
                'tracer_sigma_frac': 0.08,
            },
        }
        
        return configs.get(case, configs['case1'])
    
    @staticmethod
    def validate_config(config: Dict[str, Any]) -> bool:
        """
        Validate configuration parameters.
        
        Args:
            config: Configuration dictionary
        
        Returns:
            True if valid
        
        Raises:
            ValueError: If configuration is invalid
        """
        required = ['Lx', 'Ly', 'U0', 'nx', 'ny', 'dt']
        
        for key in required:
            if key not in config:
                raise ValueError(f"Missing required parameter: {key}")
        
        if config.get('Lx', 0) <= 0 or config.get('Ly', 0) <= 0:
            raise ValueError("Domain size must be positive")
        
        if config.get('U0', 0) <= 0:
            raise ValueError("Velocity U0 must be positive")
        
        if config.get('dt', 0) <= 0:
            raise ValueError("Time step dt must be positive")
        
        if config.get('nx', 0) < 10 or config.get('ny', 0) < 10:
            raise ValueError("Mesh resolution must be >= 10")
        
        return True
